class Lab2 {
    public static void main(String[] args) {
        int [] arr = {1,2,2,2,3,3,3,3};
        int maxCnt = Integer.MIN_VALUE;
        int mem = arr[0];
        int cur = arr[0];
        int curCnt = 1; //
        int mode = arr[0];
        for (int idx=1;idx<arr.length;idx++) {
            cur = arr[idx];
            if (cur==mem) {
                curCnt++;
            } else {
                if (curCnt > maxCnt) {
                    mode = mem;
                    maxCnt = curCnt;
                }
                curCnt = 1; //
                mem = cur; // แก้เมื่อกี้ ง่ายขึ้น
            }
        }
        if (curCnt > maxCnt) {  //
            mode = mem; //
            maxCnt = curCnt;
        }
        System.out.println("mode = " + mode + " freq = " + maxCnt);
    }
}

/* mem = memory ค่าที่บันทึกไว้นับอยู่ว่าจะซ้ำไปกี่ตัว เปลี่ยนค่าเมื่อเลขนั้นหยุดซ้ำแล้ว cur!=mem -> mem=curแทน
cur = current ค่าปัจจุบัน เปลี่ยนตำแหน่งไปเรื่อยๆเมื่อลูปแต่ละครั้ง
curCnt = currentCount นับว่าตอนนี้เลขที่กำลังดูซ้ำไปกี่ครั้งแล้ว เพิ่มเมื่อ cur=mem กลับไปรีเซ็ตเมื่อ cur!=mem
mode เลขที่ซ้ำมากที่สุด ณ ตอนนี้
maxCnt = maxCount ตัวเลขที่ตอนนี้ซ้ำเยอะที่สุด(mode)ซ้ำกี่ครั้ง เปลี่ยนเมื่อ cur!=mem ถ้า curCnt>maxCnt -> maxCnt=curCnt
idx = หลัก ใน arr มีหลักตั้งแต่0-7 ในลูปเริ่มตั้งแต่หลัก1เพราะจะเอาไปเช็คกับหลัก0

สิ่งที่ให้มาแล้วต้องเอามาคิด
mem เริ่มidxที่0
curCnt ต้องเริ่มจาก1 เพราะอย่างน้อยต้องมีเลขในarrayแน่ๆ1ตัว
maxCnt = Integer.MIN_VALUE ต้องการให้เปลี่ยนค่าเป็นค่าอื่น เลขทุกตัวในโลกจะมากกว่า Integer.MIN_VALUEอยู่แล้ว

การทำงาน
ค่า cur(เริ่มจาก idx ที่1) เทียบกับ mem(idxที่0)
 -> ถ้าเท่ากัน(cur=mem) จะเพิ่ม curCnt(นับครั้งซ้ำเพิ่มอีก1) แล้วจบ ไปทำลูปครั้งต่อไป(idxเพิ่มอีกทีละ1)
 -> ถ้าค่า cur!=mem จะไปเช็คว่า curCnt>maxCnt(จำนวนซ้ำที่นับอยู่ตอนนี้มากกว่าจำนวนซ้ำที่มากที่สุดที่เคยบันทึกไว้) มั้ย { ถ้ามากกว่า ให้ mode=mem(เลขที่ซ้ำมากที่สุดตอนนี้ มีค่าเท่ากับ เลขที่กำลังนับอยู่) และ maxCnt=curCnt(จำนวนครั้งมากที่สุด มีค่าเท่ากับ จำนวนครั้งที่กำลังนับอยู่) } -> แล้วรีเซ็ตค่า curCnt=1(เพราะหลังจากนี้จะเปลี่ยนเลขเช็คแล้ว ต้องกลับไปนับ1ของเลขตัวใหม่) และ mem=cur(curคือค่าปัจจุบัน เปลี่ยนเพราะถ้าค่าเก่าไม่เท่ากับค่าปัจจุบันให้เปลี่ยนให้มันเท่า เพื่อเอาไปเช็คครั้งต่อไป)

เมื่อหมดลูป : if (curCnt > maxCnt) {	|	ถ้าจำนวนซ้ำที่นับอยู่มากกว่าจำนวนซ้ำที่มากที่สุดที่เคยบันทึกไว้
	mode=mem(เลขที่ซ้ำมากที่สุดตอนนี้ มีค่าเท่ากับ เลขที่กำลังนับอยู่) 
	maxCnt=curCnt(จำนวนครั้งมากที่สุด มีค่าเท่ากับ จำนวนครั้งที่กำลังนับอยู่)
**** ถ้าไม่มี if เช็คตรงนี้ maxCntกับmode อาจจะเป็นค่าเก่า เพราะในลูปถ้าซ้ำจนจบลูปจะไม่เปลี่ยนค่า */